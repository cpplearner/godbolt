<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Compiler Explorer Tool</title>
<style>
body{overflow: scroll}
button, label, summary{font-size: 18px}
.toggle{cursor: pointer}
.toggle:not(.full) > .full{display: none}
.toggle.full > .abbr{display: none}
.tablist, .tabpanels{display: flex; width: 100%; padding: 0; margin: 0; flex-flow: row wrap}
.tablist > *, .tabpanels > *{flex: auto}
.tab{display: grid; border: 1px solid; border-radius: 5px 5px 0 0}
.addtab{display: inline; padding: 0 15px; border: none; flex: none; font-weight: bold}
label:not([hidden]) + .setlabel{display: none}
#expand{width: 25px; padding-top: 5px; position: absolute; right: 10px}
#expand.full + #code{height: calc(100vh - 80px)}
#format{padding-top: 5px; position:absolute; right: 40px}
#code, output{font-family: monospace; word-break: break-all; white-space: pre-wrap}
#code textarea{height: calc(100vh - 350px); margin: 1px}
#container label{white-space: nowrap}
.input{width: 100%; box-sizing: border-box; padding: 1px; margin: 1px}
#fromlink{display: flex}
#fromlink > button{flex: none}
#fromlink > input{flex: auto}
#output:not([data-loading="0"])::before{content: 'loading...'; display: block}
#stdout:not(:empty)::before, #stderr:not(:empty)::before{content: attr(id) ':'; font-size: x-small}
output div{contain: layout style paint}
output .bold{font-weight: bold}
output .red{color: red}
output .green{color: green}
output .yellow{color: orange}
output .blue{color: blue}
output .magenta{color: magenta}
output .cyan{color: darkcyan}
output .bold.green:only-child{font-weight: normal}
</style>
<ul id="filenames" class="tablist" data-panels="code"><li class="tab">
<label><input type=radio name="code" checked><a class="text"></a></label><input class="setlabel">
<li class="addtab">+</ul>
<span id="expand" class="toggle"><button class="abbr">v</button><button class="full">^</button></span>
<span id="format"><button>format</button></span>
<div id="code" class="tabpanels"><textarea></textarea></div>
<input id="goptions" class="input">
<ul class="tablist" data-panels="container"><li class="tab">
<label><input type=radio name="container" checked><a class="text"></a></label><input class="setlabel">
<li class="addtab">+</ul>
<ul id="container" class="tabpanels"><li class="panel">
<input class="input options">
<select class="input compiler"><option value="gsnapshot"></select>
<details class="filters" open><summary>options</summary>
<label><input type=checkbox name="binary" data-enableif="supportsBinary">binary</label>
<label><input type=checkbox name="execute" data-enableif="supportsExecute">execute</label>
<label><input type=checkbox name="labels" checked>labels</label>
<label><input type=checkbox name="libraryCode" data-enableif="supportsLibraryCodeFilter" checked>libraryCode</label>
<label><input type=checkbox name="directives" checked>directives</label>
<label><input type=checkbox name="commentOnly" checked>commentOnly</label>
<label><input type=checkbox name="trim" checked>trim</label>
<label><input type=checkbox name="intel" data-enableif="supportsIntel" checked>intel</label>
<label><input type=checkbox name="demangle" data-enableif="supportsDemangle" checked>demangle</label>
</details>
<details><summary>execute</summary>
<input class="input exeargs">
<textarea class="input stdin" placeholder="stdin"></textarea>
</details>
<button name="asm">assembly</button>
<button name="output">output</button>
<button name="ast" data-enableif="supportsAstView">ast</button>
</ul>
<div id="fromlink" class="input"><input value="https://godbolt.org/z/ovv6aq8x5"><button>fill</button></div>
<output id="output" data-loading="1"></output><output id="stdout"></output><output id="stderr"></output>
<script>
let request = (url, req = {}, type = 'application/json') =>
	fetch('https://godbolt.org/api'+url, {...req, headers: {'Content-Type': type, 'Accept': type}});
let cacheGet = async (cache, i, url) => JSON.parse(cache[i] ??= await request(url).then(x => x.text()));
let stored = (s) => JSON.parse(sessionStorage[s]) ?? [];
let getCompilers = (use_cache = sessionStorage) => cacheGet(use_cache, 'compilers',
	'/compilers?fields=id,name,lang,groupName,' +
	'supportsBinary,supportsExecute,supportsLibraryCodeFilter,supportsIntel,supportsDemangle,supportsAstView');
let getInfo = (s, use_cache = localStorage) => cacheGet(use_cache, 'preload', '/shortlinkinfo/'+s);
let compile = (id, body) => request('/compiler/'+id+'/compile', {method: 'post', body}).then(x => x.json());
let format = (body) => request('/format/clangformat', {method: 'post', body}).then(x => x.json());
let qS = (selector) => document.querySelector(selector);
let qSA = (selector) => [...document.querySelectorAll(selector)];
let create = (tag, props) => Object.assign(document.createElement(tag), props);
function init(node, nodes = []) {
	node.replaceChildren(...nodes);
	return node;
}
let make_toggle = ({abbr, full, tooltip = ''}) => `<span class="toggle"><span class="abbr" title="${tooltip}">`+
	`${abbr}</span><span class="full">${full}</span></span>`;
document.addEventListener('click', e => e.target.closest('.toggle')?.classList.toggle('full'));
function allowsetlabel(node, label = node.querySelector('label'), setlabel = node.querySelector('.setlabel')) {
	label.addEventListener('dblclick', e => label.hidden = true);
	['blur', 'change'].forEach(n => setlabel.addEventListener(n, e => {
		node.querySelector('.text').text = setlabel.value;
		label.hidden = false;
	}));
}
qSA('.tablist').forEach(b => b.addEventListener('click', e => {
	const i = [...b.childNodes].indexOf(b.querySelector(':checked').closest('.tab') ?? b.firstChild);
	if (e.target.matches('.addtab')) {
		[b, qS('#'+b.dataset.panels)].forEach(e => e.childNodes[i].after(e.childNodes[i].cloneNode(true)));
		allowsetlabel(b.childNodes[i+1]);
	}
	[...qS('#'+b.dataset.panels).childNodes].forEach(b => b.hidden = true);
	qS('#'+b.dataset.panels).childNodes[i].hidden = false;
}));
qS('#format').addEventListener('click', () => {
	const t = qS('#code textarea:not([hidden])');
	format(JSON.stringify({base: 'LLVM', source: t.value})).then(x => t.value = x.answer);
});
function reinitpanel(s, p = s.closest('.panel'), c = stored('compilers').find(x => x.id === s.value)) {
	const i = qSA('.panel').indexOf(p);
	if (c?.groupName) qS('[data-panels="container"]').childNodes[i].querySelector('.text').text = c.groupName;
	[...p.querySelectorAll('[data-enableif]')].forEach(x => x.disabled = !c?.[x.dataset.enableif]);
}
qS('#container').addEventListener('input', e => e.target.matches('.compiler') && reinitpanel(e.target));
function loadstate({sessions: [s]}, startup, t = qS('[data-panels="container"]')) {
	if (!startup) qS('#code textarea').value = s.source;
	init(t, [...[...s.compilers, ...s.executors].map(() => t.firstChild.cloneNode(true)), t.lastChild]);
	init(qS('#container'), [...s.compilers, ...s.executors.map(x => x.compiler)].map(c => {
		const panel = qS('.panel').cloneNode(true);
		[panel.querySelector('.options').value, panel.querySelector('.compiler').value] = [c.options, c.id];
		[...panel.querySelectorAll('input[type=checkbox]')].forEach(e => e.checked = c.filters[e.name]);
		return panel;
	}));
	[...t.querySelectorAll('.tab')].forEach(e => allowsetlabel(e));
	qSA('.panel').forEach(p => reinitpanel(p.querySelector('.compiler'), Object.assign(p, {hidden: true})));
	qS('#container').lastChild.hidden = false;
}
let shortlink = () => qS('#fromlink > input').value.match(/\/z\/([-\w]+)/)[1];
Promise.all([getInfo(shortlink()), getCompilers()]).then(([info, compilers]) => {
	compilers.sort((x, y) => x.id.localeCompare(y.id));
	const options = compilers.map(x => create('option', {text: x.lang+' : '+x.name, value: x.id}));
	const groups = compilers.reduce((a, x, i) => ((a[x.groupName ?? ''] ??= []).push(options[i]), a), {});
	const optgroups = Object.keys(groups).map(g => init(create('optgroup', {label: g}), groups[g]));
	qSA('.compiler').forEach(c => init(c, optgroups.map(x => x.cloneNode(true))));
	loadstate(info, true);
}).finally(() => qS('#output').dataset.loading--);
let actions = {};
let cache = {};
function display(output, attr, data) {
	const h = init(output, data.map(line => init(create('div'), [line.text]))).innerHTML;
	const s = Object.values(actions).reduce((h, f) => f(h, {attr}), h);
	if (h !== s) output.innerHTML = s;
}
qS('#fromlink > button').addEventListener('click', () => getInfo(shortlink(), false).then(loadstate));
qS('#container').addEventListener('click', async ({target: button}) => {
	if (!button.matches('button')) return;
	qS('#output').dataset.loading++;
	try {
		const p = button.closest('.panel');
		const source = qS('#code textarea').value;
		const filenames = qSA('#filenames .text').slice(1).map(a => a.text);
		const files = filenames.map((filename, i) => ({filename, contents: qS('#code').childNodes[i+1].value}));
		const compiler = p.querySelector('.compiler').value;
		const userArguments = qS('#goptions').value+' '+p.querySelector('.options').value;
		const compilerOptions = {produceAst: button.name === 'ast', executorRequest: files.length, skipPopArgs: true};
		const filters = Object.fromEntries([...p.querySelectorAll('.filters :checked')].map(e => [e.name, true]));
		const [args, stdin] = ['.exeargs', '.stdin'].map(x => p.querySelector(x).value);
		const executeParameters = {args, stdin};
		const k = JSON.stringify({source, files, compiler, userArguments, filters, executeParameters});
		let res = cache[k];
		if (!res || button.name === 'ast' && !res.astOutput) {
			const options = {userArguments, compilerOptions, filters, executeParameters};
			res = await compile(compiler, JSON.stringify({source, files, options}));
			if (res.okToCache) cache[k] = {...cache[k], ...res};
		}
		const [output, out, err] = qSA('output').map(output => init(output));
		if (button.name === 'ast')
			display(output, 'ast', res.astOutput ?? []);
		else if (button.name === 'asm')
			display(output, 'asm', res.asm ?? []);
		else if ((res.execResult ?? res)?.didExecute === false)
			[out, err].forEach(o => display(o, '', (res.execResult ?? res).buildResult[o.id]));
		else
			[out, err].forEach(o => display(o, '', (res.execResult ?? res)[o.id]));
	} finally {
		qS('#output').dataset.loading--;
	}
});
let add_action = (f) => actions[f.name] = window[f.name] = f;
let replace = (html, re, cb) => html.replace(/(?<=^|>)(.+?)(?=<|$)/g, (m, p1) => p1.replace(re, cb));
add_action(function colorize(html, e) {
	if (e.attr === 'asm') return html;
	const classmap = {
		0: '', 1: 'bold', 31: 'red', 32: 'green', 33: 'yellow', 34: 'blue', 35: 'magenta', 36: 'cyan',
	};
	return replace(html, /\x1B\[(.*?)m(?:\x1B\[K)?(.*?)(?=\x1B\[|$)/mg,
		(m, p1, p2) => '<span class="'+p1.split(';').map(x => classmap[+x]).join(' ')+'">'+p2+'</span>');
});
add_action(function hyperlink(html, e) {
	if (e.attr === 'asm') return html;
	return replace(html, /\x1B\]8;;(.*?)\x07(.*?)\x1B]8;;\x07/g, (m, p1, p2) => '<a href="'+p1+'">'+p2+'</a>');
});
add_action(function shorten_filename(html, e) {
	const f = [
		'/opt/compiler-explorer/(?:libs/(?:\\S*?/include/(?=[^\\s/]*?/))?|\\S*?/include/c\\+\\+/[^\\s/]*?/)',
		'/tmp/compiler-explorer-compiler\\S*?/',
	];
	return replace(html, RegExp(f.join('|'), 'g'), m => make_toggle({abbr: '.../', full: m, tooltip: m}));
});
add_action(function strip_ast_output(html, e) {
	if (e.attr !== 'ast') return html;
	const raddress = /<span class=" yellow"> 0x[a-f0-9]+<\/span>/g;
	const rimp = /<[^>]+>\|-(<[^>]+>)+\w+(<[^>]+>)+ &lt;(<[^>]+>)+&gt; (<[^>]+>)+ [^]*?\n(?=<[^>]+>[|`]-)/g;
	return html.replace(raddress, '').replace(rimp, '');
});
add_action(function shorten_std_names(html, e) {
	const rstring = '\\bstd::basic_string&lt;(char)(, std::char_traits&lt;\\1&gt;, std::allocator&lt;\\1&gt; )?&gt;'
		+ '( (?=&gt;))?';
	return replace(replace(html, /\bstd::__\w+::/g, () => 'std::'), RegExp(rstring, 'g'), () => 'std::string');
});
add_action(function shorten_decl(html, e) {
	return replace(html, /^.*$/g, (m) => {
		try {
			let re = /&lt;&lt;|-&gt;|(\(|\[|&lt;)|(\)|\]|&gt;)|($)/g;
			for (let s = '', r, lastindex, stack = []; r = re.exec(m); lastindex = r.index) {
				s += m.slice(lastindex, r.index);
				if (r[1]) stack.push({...r, pos: s.length});
				if (r[2]) {
					while (r[0] !== '&gt;' && stack[stack.length - 1][1] !== {')': '(', ']': '['}[r[0]])
						stack.pop();
					if (r[0] !== '&gt;' || stack[stack.length - 1][1] === '&lt;') {
						const l = stack.pop();
						const [abbr, full] = [l[0]+'...', s.slice(l.pos)];
						const tooltip = m.slice(l.index + l[0].length, r.index);
						if (r.index - l.index - abbr.length > 30)
							s = s.slice(0, l.pos) + make_toggle({abbr, full, tooltip});
					}
				}
				if (r[3] === '') return s;
			}
		} catch (e) {
			return m;
		}
	});
});
</script>
