<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Compiler Explorer Tool</title>
<style>
body{overflow: scroll}
button, label, summary{font-size: 18px}
.toggle{cursor: pointer}
.toggle:not(.full) > .full{display: none}
.toggle.full > .abbr{display: none}
.tablist, .tabpanels{display: flex; width: 100%; padding: 0; margin: 0; flex-flow: row wrap}
.tablist > *, .tabpanels > *{flex: auto}
.tab{display: grid; border: 1px solid; border-radius: 4px 4px 0 0}
.addtab{display: inline; padding: 0 15px; border: none; flex: none; font-weight: bold}
label:not([hidden]) + .setlabel{display: none}
#expand{padding-top: 5px; position: absolute; right: 10px}
#expand.full + #code{height: calc(100vh - 50px)}
#code, output{font-family: monospace; word-break: break-all; white-space: pre-wrap}
#code{height: calc(100vh - 320px); margin: 1px}
#container label{white-space: nowrap}
.input{width: 100%; box-sizing: border-box; padding: 1px; margin: 1px}
#fromlink{display: flex}
#fromlink > button{flex: none}
#fromlink > input{flex: auto}
#output:not([data-loading="0"])::before{content: 'loading...'; display: block}
#stdout:not(:empty)::before, #stderr:not(:empty)::before{content: attr(id) ':'; font-size: x-small}
output .bold{font-weight: bold}
output .red{color: red}
output .green{color: green}
output .yellow{color: orange}
output .blue{color: blue}
output .magenta{color: magenta}
output .cyan{color: darkcyan}
output .bold.green:only-child{font-weight: normal}
</style>
<ul id="filenames" class="tablist" data-panels="code"><li class="tab">
<label><input type=radio name="code" checked><a class="text"></a></label><input class="setlabel">
<li class="addtab">+</ul>
<span id="expand" class="toggle"><button class="abbr">v</button><button class="full">^</button></span>
<div id="code" class="tabpanels"><textarea></textarea></div>
<input id="goptions" class="input">
<ul class="tablist" data-panels="container"><li class="tab">
<label><input type=radio name="container" checked><a class="text"></a></label><input class="setlabel">
<li class="addtab">+</ul>
<ul id="container" class="tabpanels"><li class="panel">
<input class="input options">
<select class="input compiler"><option value="gsnapshot"></select>
<details><summary>include libs</summary><select class="input libs" multiple></select></details>
<details class="filters" open><summary>options</summary>
<label><input type=checkbox name="binary" data-enableif="supportsBinary">binary</label>
<label><input type=checkbox name="execute" data-enableif="supportsExecute">execute</label>
<label><input type=checkbox name="labels" checked>labels</label>
<label><input type=checkbox name="libraryCode" data-enableif="supportsLibraryCodeFilter" checked>libraryCode</label>
<label><input type=checkbox name="directives" checked>directives</label>
<label><input type=checkbox name="commentOnly" checked>commentOnly</label>
<label><input type=checkbox name="trim" checked>trim</label>
<label><input type=checkbox name="intel" data-enableif="supportsIntel" checked>intel</label>
<label><input type=checkbox name="demangle" data-enableif="supportsDemangle" checked>demangle</label>
</details>
<details><summary>execute</summary>
<input class="input exeargs">
<textarea class="input stdin" placeholder="stdin"></textarea>
</details>
<button name="asm">assembly</button>
<button name="output">output</button>
<button name="ast" data-enableif="supportsAstView">ast</button>
</ul>
<div id="fromlink" class="input"><input value="https://godbolt.org/z/ovv6aq8x5"><button>fill</button></div>
<output id="output" data-loading="1"></output><output id="stdout"></output><output id="stderr"></output>
<script>
let request = (url, req = {}, type = 'application/json') =>
	fetch('https://godbolt.org/api'+url, {...req, headers: {'Content-Type': type, 'Accept': type}});
let cacheGet = async (cache, i, url, f = undefined) =>
	JSON.parse(cache[i]  ||= await request(url).then(x => x.text()).then(f));
let stored = (s) => JSON.parse(sessionStorage[s]) || [];
let getCompilers = (use_cache = sessionStorage) => cacheGet(use_cache, 'compilers',
	'/compilers?fields=id,name,lang,group,groupName,libs,remote,tools,' +
	'supportsBinary,supportsExecute,supportsLibraryCodeFilter,supportsIntel,supportsDemangle,supportsAstView',
	x => JSON.stringify(JSON.parse(x).map(x => ({...x, libs: x.remote ? x.libs : undefined}))));
let getLibs = (use_cache = sessionStorage) => cacheGet(use_cache, 'libs', '/libraries');
let getInfo = (s, use_cache = localStorage) => cacheGet(use_cache, 'preload', '/shortlinkinfo/'+s);
let compile = (id, body) => request('/compiler/'+id+'/compile', {method: 'post', body}).then(x => x.json());
let qS = (selector) => document.querySelector(selector);
let create = (tag, props) => Object.assign(document.createElement(tag), props);
function init(node, nodes = []) {
	node.replaceChildren(...nodes);
	return node;
}
let initselect = (parent, f, groups, p) =>
	init(parent, groups.map(g => init(create('optgroup', {label: g}), f(g).map(t => create('option', p(t))))));
let make_toggle = ({abbr, full, tooltip = ''}) => '<span class="toggle"><span class="abbr" title="'+tooltip+'">'
	+abbr+'</span><span class="full">'+full+'</span></span>';
document.addEventListener('click', e => e.target.closest('.toggle')?.classList.toggle('full'));
function allowsetlabel(node) {
	node.querySelector('label').addEventListener('dblclick', e => node.querySelector('label').hidden = true);
	['blur', 'change'].map(n => node.querySelector('.setlabel').addEventListener(n, e => {
		node.querySelector('.text').text = e.target.value;
		node.querySelector('label').hidden = false;
	}));
}
for (const b of document.querySelectorAll('.tablist')) {
	b.addEventListener('click', e => {
		const i = [...b.childNodes].indexOf(e.target.closest('.tab') || b.firstChild);
		if (e.target.matches('.addtab')) {
			[b, qS('#'+b.dataset.panels)].forEach(e => e.childNodes[i].after(e.childNodes[i].cloneNode(true)));
			allowsetlabel(b.childNodes[i+1]);
		}
		[...qS('#'+b.dataset.panels).childNodes].forEach(b => b.hidden = true);
		qS('#'+b.dataset.panels).childNodes[i].hidden = false;
	});
}
function reinitpanel(s, p = s.closest('.controller'), c = stored('compilers').find(x => x.id === s.value)) {
	if (!c) return;
	const i = [...qS('#container').childNodes].indexOf(p);
	if (c.groupName) qS('[data-panels="container"]').childNodes[i].querySelector('.text').text = c.groupName;
	[...p.querySelectorAll('[data-enableif]')].forEach(x => x.disabled = !c[x.dataset.enableif]);
	const libs = c.libs || stored('libs')[c.lang];
	const f = group => {
		const [id, info] = Object.entries(libs).find(x => x[1].name === group);
		return Object.entries(info.versions).map(x => ({...x, id}));
	};
	const prop = x => ({text: x[1].version, value: JSON.stringify({id: x.id, version: x[0]})});
	initselect(p.querySelector('.libs'), f, Object.values(libs).map(x => x.name), prop);
}
qS('#container').addEventListener('input', e => e.target.matches('.compiler') && reinitpanel(e.target));
function loadstate(data, startup) {
	if (!startup) qS('#code textarea').value = data.sessions[0].source;
	const t = qS('[data-panels="container"]');
	init(t, [...data.sessions[0].compilers.map(() => t.firstChild.cloneNode(true)), t.lastChild]);
	[...t.querySelectorAll('.tab')].forEach(allowsetlabel);
	init(qS('#container'), data.sessions[0].compilers.map(c => {
		const panel = qS('#container > li').cloneNode(true);
		[panel.querySelector('.options').value, panel.querySelector('.compiler').value] = [c.options, c.id];
		[...panel.querySelectorAll('input[type=checkbox]')].forEach(e => e.checked = c.filters[e.name]);
		return panel;
	}));
	for (const p of qS('#container').childNodes)
		reinitpanel(p.querySelector('.compiler'), Object.assign(p, {hidden: true}));
	qS('#container').lastChild.hidden = false;
}
let shortlink = () => qS('#fromlink > input').value.match(/\/z\/([-\w]+)/)[1];
Promise.all([getInfo(shortlink()), getCompilers(), getLibs()]).then(([x, data], gN = v => v.groupName || '') => {
	data.sort((x, y) => x.id.localeCompare(y.id));
	const f = group => data.filter(x => gN(x) === group);
	for (const c of document.querySelectorAll('.compiler'))
		initselect(c, f, [...new Set(data.map(gN))], x => ({text: x.lang+' : '+x.name, value: x.id}));
	loadstate(x, true);
	qS('#output').dataset.loading--;
});
let actions = {};
let cache = {};
function display(output, attr, data) {
	const h = init(output, data.map(line => init(create('div'), [line.text]))).innerHTML;
	const s = Object.values(actions).reduce((h, f) => f(h, {attr}), h);
	if (h !== s) output.innerHTML = s;
}
qS('#fromlink > button').addEventListener('click', () => getInfo(shortlink(), false).then(loadstate));
qS('#container').addEventListener('click', async ({target: button}) => {
	if (!button.matches('button')) return;
	qS('#output').dataset.loading++;
	try {
		const p = button.closest('.panel');
		const source = qS('#code textarea').value;
		const filenames = [...document.querySelectorAll('#filenames .text')].slice(1).map(a => a.text);
		const files = filenames.map((filename, i) => ({filename, contents: qS('#code').childNodes[i+1].value}));
		const compiler = p.querySelector('.compiler').value;
		const userArguments = qS('#goptions').value+' '+p.querySelector('.options').value;
		const compilerOptions = {produceAst: button.name === 'ast', executorRequest: files.length, skipPopArgs: true};
		const libraries = [...p.querySelector('.libs').selectedOptions].map(x => JSON.parse(x.value));
		const filters = Object.fromEntries([...p.querySelectorAll('.filters :checked')].map(e => [e.name, true]));
		const [args, stdin] = ['.exeargs', '.stdin'].map(x => p.querySelector(x).value);
		const executeParameters = {args, stdin};
		const k = JSON.stringify({source, files, compiler, userArguments, filters, libraries, executeParameters});
		let res = cache[k];
		if (!res || button.name === 'ast' && !res.astOutput) {
			const options = {userArguments, compilerOptions, filters, libraries, executeParameters};
			res = await compile(compiler, JSON.stringify({source, files, options}));
			if (res.okToCache) cache[k] = {...cache[k], ...res};
		}
		const [output, out, err] = [...document.querySelectorAll('output')].map(output => init(output));
		if (button.name === 'ast')
			display(output, 'ast', res.astOutput || []);
		else if (button.name === 'asm')
			display(output, 'asm', res.asm || []);
		else if (res.execResult?.didExecute === false)
			[out, err].forEach(o => display(o, '', res.execResult.buildResult[o.id]));
		else if (res.execResult)
			[out, err].forEach(o => display(o, '', res.execResult[o.id]));
		else if (res.didExecute === false)
			[out, err].forEach(o => display(o, '', res.buildResult[o.id]));
		else
			[out, err].forEach(o => display(o, '', res[o.id]));
	} finally {
		qS('#output').dataset.loading--;
	}
});
let add_action = (f) => actions[f.name] = window[f.name] = f;
let replace = (html, re, cb) => html.replace(/>([^]+?)</g, (m, p1) => `>${p1.replace(re, cb)}<`);
add_action(function colorize(html, e) {
	if (e.attr === 'asm') return html;
	const classmap = {
		0: '', 1: 'bold', 31: 'red', 32: 'green', 33: 'yellow', 34: 'blue', 35: 'magenta', 36: 'cyan',
	};
	return replace(html, /\x1B\[(.*?)m(?:\x1B\[K)?(.*?)(?=\x1B\[|$)/mg,
		(m, p1, p2) => '<span class="'+p1.split(';').map(x => classmap[+x]).join(' ')+'">'+p2+'</span>');
});
add_action(function hyperlink(html, e) {
	if (e.attr === 'asm') return html;
	return replace(html, /\x1B\]8;;(.*?)\x07(.*?)\x1B]8;;\x07/g, (m, p1, p2) => '<a href="'+p1+'">'+p2+'</a>');
});
add_action(function shorten_filename(html, e) {
	const f = [
		'/opt/compiler-explorer/(?:libs/(?:\\S*?/include/(?=[^\\s/]*?/))?|\\S*?/include/c\\+\\+/[^\\s/]*?/)',
		'/tmp/compiler-explorer-compiler\\S*?/',
	];
	return replace(html, RegExp(f.join('|'), 'g'), m => make_toggle({abbr: '.../', full: m, tooltip: m}));
});
add_action(function strip_ast_output(html, e) {
	if (e.attr !== 'ast') return html;
	const raddress = /<span class=" yellow"> 0x[a-f0-9]+<\/span>/g;
	const rimp = /<[^>]+>\|-(<[^>]+>)+\w+(<[^>]+>)+ &lt;(<[^>]+>)+&gt; (<[^>]+>)+ [^]*?\n(?=<[^>]+>[|`]-)/g;
	return html.replace(raddress, '').replace(rimp, '');
});
add_action(function shorten_std_names(html, e) {
	const rstring = '\\bstd::basic_string&lt;(char)(, std::char_traits&lt;\\1&gt;, std::allocator&lt;\\1&gt; )?&gt;'
		+ '( (?=&gt;))?';
	return html.replace(/\bstd::__\w+::/g, 'std::').replace(RegExp(rstring, 'g'), 'std::string');
});
add_action(function shorten_decl(html, e) {
	return replace(html, /^.*$/g, (m) => {
		try {
			let re = /&lt;&lt;|-&gt;|(\(|\[|&lt;)|(\)|\]|&gt;)|($)/g;
			for (let s = '', r, lastindex, stack = []; r = re.exec(m); lastindex = r.index) {
				s += m.slice(lastindex, r.index);
				if (r[1]) stack.push({...r, pos: s.length});
				if (r[2]) {
					while (r[0] !== '&gt;' && stack[stack.length - 1][1] !== {')': '(', ']': '['}[r[0]])
						stack.pop();
					if (r[0] !== '&gt;' || stack[stack.length - 1][1] === '&lt;') {
						const l = stack.pop();
						const [abbr, full] = [l[0]+'...', s.slice(l.pos)];
						const tooltip = m.slice(l.index + l[0].length, r.index);
						if (r.index - l.index - abbr.length > 30)
							s = s.slice(0, l.pos) + make_toggle({abbr, full, tooltip});
					}
				}
				if (r[3] === '') return s;
			}
		} catch (e) {
			return m;
		}
	});
});
</script>
