<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Compiler Explorer Tool</title>
<style>
button, label { font-size: 20px }
#expand { position: absolute; left: calc(100vw - 75px) }
#expand::after { content: "v" }
#expand[data-delta^="-"]::after { content: "^" }
#code, #output { font-family: monospace; word-break: break-all; white-space: pre-wrap }
#code { width: calc(100vw - 42px); height: calc(100vh - 250px); margin: 1px; resize: vertical }
#container { width: calc(100vw - 35px); overflow: auto }
.controller { display: table-cell }
.controller label { white-space: nowrap }
.compiler, .options { width: calc(100vw - 36px); box-sizing: border-box; padding: 1px; margin: 1px }
#sharelink { display: block; word-break: break-all; white-space: pre-wrap }
#loading[data-show="0"] { display: none }
#output .bold { font-weight: bold }
#output .red { color: red }
#output .green { color: green }
#output .yellow { color: orange }
#output .blue { color: blue }
#output .magenta { color: magenta }
#output .cyan { color: darkcyan }
#output .bold.green:only-child { font-weight: normal }
#output .toggle { cursor: pointer }
#output .toggle > .full { display: none }
#output .toggle.full > .abbr { display: none }
#output .toggle.full > .full { display: unset }
</style>
<button id="expand" data-delta="200"></button>
<textarea id="code"></textarea>
<div id="container">
<p class="controller">
<select class="compiler"><option value="gsnapshot">x86-64 gcc (trunk)</select>
<input class="options" value="-std=c++2a -Wall -pedantic -fdiagnostics-color=always">
<p class="controller">
<select class="compiler"><option value="clang_trunk">x86-64 clang (trunk)</select>
<input class="options" value="-std=c++2a -Wall -pedantic -stdlib=libstdc++ --gcc-toolchain=/opt/compiler-explorer/gcc-snapshot -fdiagnostics-color=always">
<p class="controller">
<select class="compiler"><option value="clang_trunk">x86-64 clang (trunk)</select>
<input class="options" value="-std=c++2a -Wall -pedantic -stdlib=libc++ -fmodules -fdiagnostics-color=always">
<p class="controller">
<select class="compiler"><option value="cl19_64">x86-64 CL 19 2017 RTW</select>
<input class="options" value="/EHsc /std:c++latest /permissive- /utf-8">
</div>
<a id="sharelink"></a>
<div id="loading">loading...</div>
<output id="output"></output>
<template id="filters">
<div>
<label><input type=checkbox name="binary">binary</label>
<label hidden><input type=checkbox name="execute">execute</label>
<label><input type=checkbox name="labels" checked>labels</label>
<label><input type=checkbox name="directives" checked>directives</label>
<label><input type=checkbox name="commentOnly" checked>commentOnly</label>
<label><input type=checkbox name="trim" checked>trim</label>
<label><input type=checkbox name="intel" checked>intel</label>
<label><input type=checkbox name="demangle" checked>demangle</label>
</div>
<div>
<button name="asm">assembly</button>
<button name="stderr">stderr</button>
<button name="stdout">stdout</button>
<button name="ast">ast</button>
<button name="share">share</button>
</div>
</template>
<script>
let create = (tag, props) => Object.assign(document.createElement(tag), props);
let request = (url, init) => fetch('https://godbolt.org/api'+url, init);
function getCompilers(use_cache = sessionStorage.getItem('compilers')) {
	if (use_cache) return Promise.resolve(JSON.parse(use_cache));
	const t = request('/compilers', { headers: { 'Accept': 'application/json' } }).then(x => x.text());
	t.then(s => sessionStorage.setItem('compilers', s));
	return t.then(JSON.parse);
}
function compile(id, body) {
	const headers = { 'Content-Type': 'application/json', 'Accept': 'application/json' };
	return request('/compiler/'+id+'/compile', { method: 'post', headers, body }).then(x => x.json());
}
document.querySelector('#expand').addEventListener('click', (e) => {
	const code = document.querySelector('#code');
	code.style.height = `calc(${getComputedStyle(code).height} + ${e.target.dataset.delta}px)`;
	e.target.dataset.delta = -e.target.dataset.delta;
});
for (const controller of document.querySelectorAll('.controller'))
	controller.append(document.querySelector('#filters').content.cloneNode(true));
getCompilers().then((data) => {
	const d = data.reduce((o,v) => (o[v.group] = [...o[v.group] || [], v], o), {});
	for (const compiler of document.querySelectorAll('.compiler')) {
		const curid = compiler.value;
		compiler.textContent = '';
		for (const group in d) {
			const optgroup = create('optgroup', { label: group });
			for (const i of d[group]) {
				const option = create('option', { value: i.id, selected: i.id === curid });
				option.textContent = i.lang+' : '+i.name;
				Object.assign(option.dataset, i);
				optgroup.append(option);
			}
			compiler.append(optgroup);
		}
	}
	document.querySelector('#loading').dataset.show = 0;
});
let actions = {};
function display(data, attr, s, output = document.querySelector('#output')) {
	output.hidden = true;
	output.textContent = '';
	if (attr === 'ast')
		output.append(create('div', { textContent: data.astOutput }));
	else
		data[attr].forEach((t) => output.append(create('div', { textContent: t.text })));
	output.innerHTML = Object.values(actions).reduce((h, f) => f(h, { output, attr }), output.innerHTML);
	output.hidden = false;
}
let cache = {};
let cl_prelude = '#include <iostream>\n';
for (const w of ['', 'w']) {
	for (const t of ['short', 'int', 'long', 'long long'])
		for (const s of ['', 'unsigned'])
			cl_prelude += `extern template std::${w}ostream& std::${w}ostream::operator<<(${s} ${t});\n`;
	for (const t of ['float', 'double', 'long double', 'bool', 'const void*'])
		cl_prelude += `extern template std::${w}ostream& std::${w}ostream::operator<<(${t});\n`;
	cl_prelude += `extern template std::${w}ostream& std::operator<<(std::${w}ostream&, char);\n`;
	cl_prelude += `extern template std::${w}ostream& std::operator<<(std::${w}ostream&, const char*);\n`;
}
cl_prelude += `extern template std::wostream& std::operator<<(std::wostream&, wchar_t);\n`;
cl_prelude += `extern template std::wostream& std::operator<<(std::wostream&, const wchar_t*);\n`;
document.addEventListener('click', async (e) => {
	const button = e.target;
	const controller = button.closest('.controller');
	if (!button.matches('button') || !controller) return;
	document.querySelector('#loading').dataset.show++;
	try {
		let source = document.querySelector('#code').value;
		const compiler = controller.querySelector('.compiler').value;
		const userArguments = controller.querySelector('.options').value;
		const compilerOptions = { produceAst: true, produceGccDump: {} };
		const checkboxes = [...controller.querySelectorAll('input[type=checkbox]')];
		const filters = Object.assign(...checkboxes.map((e) => ({ [e.name]: e.checked })));
		if (controller.querySelector('.compiler').selectedOptions[0].dataset.group === 'cl19')
			source = source.replace(/^[ \t]*#[ \t]*include[ \t]*<iostream>[ \t]*\n/, cl_prelude);
		const sharelink = document.querySelector('#sharelink');
		sharelink.textContent = sharelink.href = '';
		if (button.name === 'share') {
			const es = (s) => s.replace(/['!]/g,(x) => '!'+x);
			const filter = `(${Object.entries(filters).map(([k,v]) => `${k}:'${+!v}'`).join(',')})`;
			let s = `g:!((g:!((g:!((h:codeEditor,i:(j:1,source:'${es(source)}'),l:'5')),l:'4'),(g:!((${
			`h:compiler,i:(compiler:${compiler},filters:${filter},options:'${es(userArguments)}',source:1)`
			},l:'5')),l:'4'),(g:!((h:output,i:(compiler:1,editor:1),l:'5')),l:'4')),l:'2')),version:4`;
			s = encodeURIComponent(s).replace(/%2C/g, ',').replace(/%3A/g, ':').replace(/%20/g, '+');
			sharelink.textContent = sharelink.href = 'https://godbolt.org/#'+s;
			return;
		}
		const s = JSON.stringify({ source, compiler, options: { userArguments, compilerOptions, filters } });
		const data = cache[s] || await compile(compiler, s);
		if (data.okToCache) cache[s] = data;
		display(data, button.name, s);
	} finally {
		document.querySelector('#loading').dataset.show--;
	}
});
let add_action = (f) => actions[f.name] = window[f.name] = f;
let replace = (html, re, cb) => html.replace(/>([^]*?)</g, (m,p1) => `>${p1.replace(re, cb)}<`);
let make_toggle = ({ abbr, full, tooltip = '' }) => '<span class="toggle"><span class="abbr" title="'+tooltip+'">'
	+abbr+'</span><span class="full">'+full+'</span></span>';
add_action(function colorize(html, e) {
	if (e.attr === 'asm') return html;
	const classmap = {
		0: '', 1: 'bold', 31: 'red', 32: 'green', 33: 'yellow', 34: 'blue', 35: 'magenta', 36: 'cyan',
	};
	return replace(html, /\x1B\[(.*?)m(?:\x1B\[K)?(.*?)(?=\x1B|$)/mg,
		(m, p1, p2) => '<span class="'+p1.split(';').map(x => classmap[+x]).join(' ')+'">'+p2+'</span>');
});
add_action(function shorten_filename(html, e) {
	if (e.attr === 'asm') return html;
	return replace(html,
		RegExp('/opt/compiler-explorer/.*?/include/c\\+\\+/.*?/|/tmp/compiler-explorer-compiler.*?/','g'),
		(m) => make_toggle({ abbr: '.../', full: m, tooltip: m }));
});
document.querySelector('#output').addEventListener('click', (e) => {
	const span = e.target.closest('.toggle');
	if (!span) return;
	span.classList.toggle('full');
});
add_action(function strip_ast_output(html, e) {
	if (e.attr !== 'ast') return html;
	const raddress = /<span class=" yellow"> 0x[a-f0-9]+<\/span>/g;
	const rimp = /<[^>]+>\|-(<[^>]+>)+\w+(<[^>]+>)+ &lt;(<[^>]+>)+&gt; (<[^>]+>)+ [^]*?\n(?=<[^>]+>[|`]-)/g;
	return html.replace(raddress, '').replace(rimp, '');
});
add_action(function shorten_decl(html, e) {
	return replace(html, /^.*$/g, (m) => {
		function getHTML(range) {
			let s = '';
			let curidx = range.left;
			for (let r of range.children) {
				s += m.slice(curidx, r.left);
				let str = m.slice(r.left, r.right);
				let full = getHTML(r);
				if (r.sym === '<>' && r.right - r.left > 26)
					s += make_toggle({ abbr: '&lt;...&gt;', full, tooltip: str });
				else if (r.sym === '()' && (r.children.length !== 0 || r.right - r.left > 100))
					s += make_toggle({ abbr: '(...)', full, tooltip: str });
				else
					s += str;
				curidx = r.right;
			}
			s += m.slice(curidx, range.right);
			return s;
		}
		try {
			let symidx = [];
			for (let i, re = /&lt;|&gt;|[()]/g; i = re.exec(m);) {
				symidx.push(i);
			}
			let stack = [{ left: 0, right: m.length, children: [] }];
			for (let { 0: str, index } of symidx) {
				if (str === '(') stack.push({ left: index, sym: '()', children: [] });
				if (str === ')') {
					let prange = {};
					while (prange.sym !== '()')
						prange = stack.pop();
					stack[stack.length - 1].children.push({ right: index+1, ...prange });
				}
				if (str === '&lt;') stack.push({ left: index, sym: '<>', children: [] });
				if (str === '&gt;') {
					let last = stack[stack.length - 1];
					if (last.right === undefined && last.sym === '<>') {
						let prange = stack.pop();
						stack[stack.length - 1].children.push({ right: index+4, ...prange });
					}
				}
			}
			return getHTML(stack[0]);
		} catch (e) {
			return m;
		}
	});
});
</script>
